# Полная документация проекта: HTTP-сервер загрузки файлов

## Оглавление

1. [Соответствие заданию](#1-соответствие-заданию)
2. [Структура проекта](#2-структура-проекта)
3. [Используемые технологии](#3-используемые-технологии)
   - 3.1. [Язык C и стандарт C11](#31-язык-c-и-стандарт-c11)
   - 3.2. [POSIX-сокеты (TCP)](#32-posix-сокеты-tcp)
   - 3.3. [Протокол HTTP/1.1](#33-протокол-http11)
   - 3.4. [Multipart/form-data](#34-multipartform-data)
   - 3.5. [HTTP Basic Authentication и Base64](#35-http-basic-authentication-и-base64)
   - 3.6. [HTML + JavaScript (клиентская часть)](#36-html--javascript-клиентская-часть)
   - 3.7. [Конфигурационный файл](#37-конфигурационный-файл)
   - 3.8. [systemd (служба Linux)](#38-systemd-служба-linux)
   - 3.9. [Makefile (система сборки)](#39-makefile-система-сборки)
   - 3.10. [GCC (компилятор)](#310-gcc-компилятор)
   - 3.11. [Valgrind (профилирование памяти)](#311-valgrind-профилирование-памяти)
4. [Как работает программа](#4-как-работает-программа)
   - 4.1. [Запуск сервера](#41-запуск-сервера)
   - 4.2. [Цикл обработки соединений](#42-цикл-обработки-соединений)
   - 4.3. [Разбор HTTP-запроса](#43-разбор-http-запроса)
   - 4.4. [Обработка GET-запроса](#44-обработка-get-запроса)
   - 4.5. [Обработка POST-запроса (загрузка файла)](#45-обработка-post-запроса-загрузка-файла)
   - 4.6. [Авторизация](#46-авторизация)
5. [Описание каждого файла](#5-описание-каждого-файла)
6. [Сборка, запуск и тестирование](#6-сборка-запуск-и-тестирование)
7. [Найденные и исправленные ошибки](#7-найденные-и-исправленные-ошибки)
8. [Известные ограничения](#8-известные-ограничения)

---

## 1. Соответствие заданию

| Требование | Статус | Где реализовано |
|---|---|---|
| HTTP-сервер POST-запросов | Выполнено | `src/server.c` — обработка POST на `/upload` |
| Язык C | Выполнено | Все файлы `.c`, стандарт C11 |
| Стандартные библиотеки (без сторонних) | Выполнено | Только POSIX: `stdio.h`, `string.h`, `sys/socket.h` и др. |
| Для ОС Linux | Выполнено | POSIX-сокеты, systemd, Makefile |
| С применением сокетов | Выполнено | `socket()`, `bind()`, `listen()`, `accept()`, `recv()`, `send()` |
| Клиент — браузер | Выполнено | HTML-форма с JavaScript на GET `/` |
| Загрузка файла на сервер | Выполнено | Парсинг multipart/form-data, сохранение на диск |
| Отладка в gcc | Выполнено | Флаги `-Wall -Wextra -g` в Makefile |
| Профилирование в valgrind | Выполнено | Инструкция в документации, код корректно работает под valgrind |
| Служба systemd | Выполнено | Файл `simple_http.service` |
| Настройка адреса и порта | Выполнено | Параметры `address` и `port` в `server.conf` |
| Авторизация | Выполнено | HTTP Basic Auth в `src/auth.c` |

**Все 12 требований задания выполнены.**

---

## 2. Структура проекта

```
http_service/
├── src/                    # Исходный код
│   ├── main.c              # Точка входа (функция main)
│   ├── server.c            # Основная логика сервера
│   ├── server.h            # Заголовок сервера
│   ├── http_request.c      # Разбор HTTP-запросов
│   ├── http_request.h      # Структура HTTP-запроса
│   ├── http_response.c     # Формирование HTTP-ответов
│   ├── http_response.h     # Заголовок ответов
│   ├── config.c            # Чтение конфигурации
│   ├── config.h            # Структура конфигурации
│   ├── auth.c              # Авторизация (Basic Auth + Base64)
│   ├── auth.h              # Заголовок авторизации
│   ├── multipart.c         # Парсинг multipart/form-data
│   ├── multipart.h         # Заголовок парсера
│   └── limits.h            # Константы (лимиты размеров, таймауты)
├── Makefile                # Сборка проекта
├── server.conf             # Конфигурационный файл
├── simple_http.service     # Файл службы systemd
├── test.sh                 # Скрипт автоматического тестирования
└── README.md               # Краткое описание
```

---

## 3. Используемые технологии

### 3.1. Язык C и стандарт C11

**Что это:** C — компилируемый язык программирования низкого уровня. Стандарт C11 — версия стандарта языка от 2011 года.

**Зачем используется:** Задание требует написать программу на C. C дает прямой доступ к системным вызовам Linux (сокеты, файлы), не требует внешних зависимостей и позволяет точно контролировать работу с памятью.

**Как реализовано в проекте:**
- Все исходные файлы имеют расширение `.c` и `.h`
- В Makefile указан флаг `-std=c11`, который говорит компилятору использовать стандарт C11
- Используются возможности C11: тип `bool` из `<stdbool.h>`, инициализация структур нулями `{0}`
- Никакие сторонние библиотеки не подключаются — только стандартные POSIX-заголовки

**Используемые стандартные заголовки:**

| Заголовок | Для чего |
|---|---|
| `<stdio.h>` | Ввод/вывод: `printf`, `fprintf`, `fopen`, `fwrite`, `snprintf` |
| `<string.h>` | Работа со строками: `strcmp`, `strstr`, `memset`, `memcpy`, `strncpy` |
| `<stdlib.h>` | Общие функции: `malloc`, `free`, `atoi`, `atol` |
| `<sys/socket.h>` | Сокеты: `socket`, `bind`, `listen`, `accept`, `recv`, `send` |
| `<arpa/inet.h>` | Сетевые функции: `inet_addr`, `htons` |
| `<unistd.h>` | POSIX-функции: `close`, `unlink` |
| `<errno.h>` | Коды ошибок: переменная `errno`, константы `EAGAIN`, `EWOULDBLOCK` |
| `<sys/stat.h>` | Файловая система: `stat`, `mkdir` |
| `<fcntl.h>` | Управление файлами (подключается для совместимости) |
| `<sys/time.h>` | Временные структуры: `struct timeval` для таймаутов сокетов |
| `<signal.h>` | Сигналы: `signal(SIGPIPE, SIG_IGN)` — игнорирование SIGPIPE |
| `<stdbool.h>` | Тип `bool` с значениями `true`/`false` |

---

### 3.2. POSIX-сокеты (TCP)

**Что это:** Сокеты — это механизм межпроцессного взаимодействия, который позволяет программам обмениваться данными по сети. TCP-сокеты обеспечивают надежную доставку данных в правильном порядке.

**Зачем используется:** HTTP работает поверх TCP. Браузер устанавливает TCP-соединение с сервером, отправляет запрос и получает ответ. Сокеты — это «низкоуровневый» способ реализовать такое взаимодействие без сторонних библиотек.

**Как реализовано в проекте** (файл `src/server.c`, функция `start_server`):

Сервер работает по классической схеме TCP-сервера:

```
1. socket()   — создание сокета
2. bind()     — привязка к адресу и порту
3. listen()   — начинаем слушать входящие соединения
4. accept()   — принимаем соединение от клиента (в бесконечном цикле)
5. recv()     — читаем данные от клиента
6. send()     — отправляем ответ клиенту
7. close()    — закрываем соединение
```

**Пошагово:**

1. **Создание сокета:**
   ```c
   int s = socket(AF_INET, SOCK_STREAM, 0);
   ```
   - `AF_INET` — используем IPv4
   - `SOCK_STREAM` — TCP (потоковый протокол с гарантией доставки)
   - Возвращает файловый дескриптор (число), через который мы работаем с сокетом

2. **Опция SO_REUSEADDR:**
   ```c
   int o = 1;
   setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &o, sizeof o);
   ```
   Позволяет перезапускать сервер без ожидания — иначе после остановки порт был бы «занят» ещё 1-2 минуты

3. **Привязка к адресу:**
   ```c
   struct sockaddr_in a = {0};
   a.sin_family = AF_INET;
   a.sin_port = htons(c->port);          // порт из конфига
   a.sin_addr.s_addr = inet_addr(c->address); // адрес из конфига
   bind(s, (void*)&a, sizeof a);
   ```
   - `htons()` преобразует номер порта в сетевой порядок байтов (big-endian)
   - `inet_addr()` преобразует строку "0.0.0.0" в числовой IP-адрес

4. **Начало прослушивания:**
   ```c
   listen(s, 5);
   ```
   Сокет начинает принимать входящие соединения. Число 5 — размер очереди ожидающих соединений.

5. **Цикл приёма соединений:**
   ```c
   for(;;) {
       int cl = accept(s, 0, 0);
       // ... обработка запроса ...
       close(cl);
   }
   ```
   `accept()` блокирует выполнение до прихода нового клиента, затем возвращает новый сокет для общения с этим конкретным клиентом.

6. **Таймауты сокетов:**
   ```c
   struct timeval tv;
   tv.tv_sec = SOCKET_TIMEOUT;  // 10 секунд
   tv.tv_usec = 0;
   setsockopt(cl, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
   setsockopt(cl, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
   ```
   Если клиент не отправляет данные в течение 10 секунд, `recv()` вернёт ошибку вместо бесконечного ожидания. Это защита от «зависших» соединений.

---

### 3.3. Протокол HTTP/1.1

**Что это:** HTTP (HyperText Transfer Protocol) — протокол передачи данных в вебе. Браузер отправляет HTTP-запрос, сервер отвечает HTTP-ответом. Это текстовый протокол — заголовки представляют собой обычный текст.

**Зачем используется:** Задание требует HTTP-сервер, а браузер общается именно по HTTP.

**Формат HTTP-запроса** (то, что отправляет браузер):
```
POST /upload HTTP/1.1\r\n
Host: localhost:8080\r\n
Content-Type: multipart/form-data; boundary=abc123\r\n
Content-Length: 350\r\n
Authorization: Basic YWRtaW46YWRtaW4=\r\n
\r\n
<тело запроса с данными файла>
```

- Первая строка: **метод** (GET или POST), **путь** (/upload), **версия протокола**
- Далее **заголовки** — пары «ключ: значение», каждая на отдельной строке
- Пустая строка `\r\n` отделяет заголовки от тела
- **Тело** — содержит данные (файл, форму и т.п.)

**Формат HTTP-ответа** (то, что отправляет сервер):
```
HTTP/1.1 200 OK\r\n
Content-Type: text/plain\r\n
Content-Length: 28\r\n
\r\n
File uploaded: document.pdf
```

**Как реализовано в проекте:**

Разбор запроса (`src/http_request.c`):
```c
sscanf(b, "%7s %127s", r->method, r->path);  // метод и путь
```
- `sscanf` считывает из строки метод (GET/POST) и путь (/upload)
- Заголовки `Content-Length`, `Content-Type`, `Authorization` ищутся через `strstr` (поиск подстроки)

Формирование ответа (`src/http_response.c`):
```c
snprintf(b, sizeof b, "HTTP/1.1 %d %s\r\nContent-Length:0\r\n\r\n", c, m);
send(fd, b, len, 0);
```
- `snprintf` формирует текстовый HTTP-ответ
- `send` отправляет его клиенту через сокет

**Поддерживаемые HTTP-коды ответов:**

| Код | Значение | Когда используется |
|---|---|---|
| 200 | OK | Успешная загрузка файла или выдача HTML-формы |
| 400 | Bad Request | Некорректный запрос (нет boundary, ошибка разбора) |
| 401 | Unauthorized | Неверный логин/пароль |
| 404 | Not Found | Запрос к несуществующему пути |
| 500 | Internal Server Error | Не удалось создать файл на сервере |

---

### 3.4. Multipart/form-data

**Что это:** Формат для передачи файлов через HTTP. Когда вы нажимаете «Загрузить» в браузере, файл упаковывается в этот формат. Тело запроса разделяется специальной строкой — **boundary** (границей).

**Зачем используется:** HTML-формы с `<input type="file">` отправляют файлы именно в формате multipart/form-data. Это стандартный способ загрузки файлов через браузер.

**Как выглядят данные:**
```
--boundary123\r\n
Content-Disposition: form-data; name="file"; filename="photo.jpg"\r\n
Content-Type: image/jpeg\r\n
\r\n
<бинарные данные файла>
\r\n
--boundary123--\r\n
```

- `--boundary123` — начало блока данных
- `Content-Disposition` — содержит имя поля и имя файла
- После пустой строки (`\r\n\r\n`) идут сами данные файла
- `--boundary123--` (с `--` в конце) — конец всех данных

**Как реализовано в проекте:**

1. **Извлечение boundary** (`server.c`, функция `extract_boundary`):
   Из заголовка `Content-Type: multipart/form-data; boundary=abc123` извлекается строка `abc123`.

2. **Парсинг тела запроса** (`src/multipart.c`, функция `parse_multipart`):
   - Получает данные тела (часть уже прочитана с заголовками + остальное из сокета)
   - Ищет boundary-маркер через `strstr`
   - Из заголовка `Content-Disposition` извлекает имя файла (`filename="..."`)
   - Находит начало данных файла (после `\r\n\r\n`)
   - Находит конец данных (перед следующим boundary)
   - Записывает данные файла в файл через `fwrite`

3. **Сохранение файла** (`server.c`):
   - Сначала файл создается как `upload.bin` (временное имя)
   - После парсинга, если настоящее имя файла было извлечено, файл переименовывается через `rename()`

---

### 3.5. HTTP Basic Authentication и Base64

**Что это:** HTTP Basic Authentication — простой механизм авторизации. Логин и пароль кодируются в Base64 и передаются в заголовке `Authorization`.

**Зачем используется:** Задание требует «возможность авторизации». Basic Auth — простой и стандартный способ, который поддерживается всеми браузерами и утилитами (curl).

**Как это работает:**

1. Клиент берёт строку `username:password` (например, `admin:admin`)
2. Кодирует её в Base64: `admin:admin` → `YWRtaW46YWRtaW4=`
3. Отправляет заголовок: `Authorization: Basic YWRtaW46YWRtaW4=`
4. Сервер декодирует Base64 обратно в `admin:admin`
5. Сравнивает с логином и паролем из конфигурации

**Base64** — это способ представить произвольные байты в виде текста из 64 символов (A-Z, a-z, 0-9, +, /). Каждые 3 байта кодируются в 4 символа. Это НЕ шифрование — любой может декодировать.

**Как реализовано в проекте** (`src/auth.c`):

1. **Функция `idx`** — возвращает числовое значение Base64-символа:
   - A-Z → 0-25
   - a-z → 26-51
   - 0-9 → 52-61
   - `+` → 62, `/` → 63

2. **Функция `b64`** — декодирует Base64-строку:
   - Берёт по одному символу, преобразует в 6-битное число
   - Накапливает биты в переменной `v`
   - Когда накопилось 8 бит — извлекает байт
   - Это стандартный алгоритм декодирования Base64, реализованный вручную (без внешних библиотек)

3. **Функция `check_auth`** — проверяет авторизацию:
   ```c
   int check_auth(const char *h, const server_config_t *c) {
       if (strncmp(h, "Basic ", 6)) return 0;   // проверяем что это Basic
       unsigned char d[128] = {0};
       b64(h + 6, d);                            // декодируем Base64
       char exp[128];
       snprintf(exp, sizeof exp, "%s:%s", c->username, c->password);  // ожидаемое
       return strcmp((char*)d, exp) == 0;         // сравниваем
   }
   ```

**Где вызывается:** В `server.c` перед обработкой POST-запроса:
```c
if (c->auth_enabled && !check_auth(req.authorization, c)) {
    http_error(cl, 401, "Unauthorized");
}
```
Если авторизация включена и проверка не прошла — сервер отвечает кодом 401.

---

### 3.6. HTML + JavaScript (клиентская часть)

**Что это:** HTML-форма, которую сервер отдаёт браузеру при GET-запросе к `/`. JavaScript обеспечивает отправку файла с заголовком авторизации.

**Зачем используется:** Задание требует «в качестве клиента использовать браузер и реализовать загрузку файла на сервер». HTML-форма — это интерфейс для пользователя в браузере.

**Как реализовано в проекте** (`src/server.c`, массив `html_form`):

HTML-страница встроена прямо в код сервера как строковая константа. Она содержит:

1. **HTML-форму:**
   ```html
   <form id="uploadForm" method="POST" action="/upload"
         enctype="multipart/form-data"
         onsubmit="uploadFile(event); return false;">
       <input type="file" name="file" required>
       <input type="submit" value="Upload">
   </form>
   ```
   - `enctype="multipart/form-data"` — формат отправки файлов
   - `onsubmit` — перехватывает отправку формы и вызывает JavaScript

2. **JavaScript-функция `uploadFile`:**
   - Запрашивает у пользователя логин и пароль через `prompt()`
   - Кодирует их в Base64 через `btoa(username + ':' + password)`
   - Создаёт AJAX-запрос (`XMLHttpRequest`)
   - Добавляет заголовок `Authorization: Basic ...`
   - Отправляет файл через `FormData`
   - Показывает результат (успех зелёным, ошибку красным)

**Почему JavaScript, а не просто форма?** Обычная HTML-форма не умеет добавлять произвольные HTTP-заголовки. А для Basic Auth нужен заголовок `Authorization`. Поэтому JavaScript перехватывает отправку формы и делает AJAX-запрос с нужным заголовком.

---

### 3.7. Конфигурационный файл

**Что это:** Текстовый файл `server.conf`, в котором хранятся настройки сервера. Формат — простые пары `ключ=значение`, по одной на строку.

**Зачем используется:** Задание требует «возможность конфигурирования адреса и порта сервера». Конфигурационный файл позволяет менять настройки без перекомпиляции.

**Содержимое `server.conf`:**
```
address=0.0.0.0
port=8080
upload_dir=/tmp
username=admin
password=admin
auth_enabled=true
```

| Параметр | Значение по умолчанию | Описание |
|---|---|---|
| `address` | `0.0.0.0` | IP-адрес для прослушивания. `0.0.0.0` — все сетевые интерфейсы |
| `port` | `8080` | Порт сервера |
| `upload_dir` | `/tmp` | Директория для сохранения загруженных файлов |
| `username` | `admin` | Имя пользователя для авторизации |
| `password` | `admin` | Пароль для авторизации |
| `auth_enabled` | `true` | Включить (`true`) или выключить (`false`) авторизацию |

**Как реализовано в проекте** (`src/config.c`):

1. **`default_config`** — заполняет структуру значениями по умолчанию
2. **`load_config`** — читает файл построчно:
   ```c
   while (fgets(l, sizeof l, f)) {
       if (sscanf(l, "%63[^=]=%127s", k, v) == 2) {
           // k = ключ, v = значение
       }
   }
   ```
   `sscanf` с форматом `%63[^=]=%127s` разбирает строку: читает всё до `=` как ключ, и всё после `=` как значение.

**Как используется:** При запуске путь к конфигу передается аргументом командной строки:
```bash
./simple_http server.conf
```
Если аргумент не указан — используются значения по умолчанию.

---

### 3.8. systemd (служба Linux)

**Что это:** systemd — система управления службами в Linux. Позволяет запускать программы как фоновые службы, автоматически перезапускать при сбоях, запускать при загрузке системы.

**Зачем используется:** Задание требует «настроить программу как службу systemd Linux».

**Файл `simple_http.service`:**
```ini
[Unit]
Description=Simple HTTP Upload Server
After=network.target

[Service]
ExecStart=/usr/local/bin/simple_http /etc/simple_http.conf
Restart=on-failure
User=nobody
Group=nogroup
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

**Разбор по секциям:**

**[Unit]** — описание и зависимости:
- `Description` — текстовое описание службы
- `After=network.target` — запускать только после того, как сеть будет готова (иначе `bind()` может не сработать)

**[Service]** — как запускать:
- `ExecStart` — команда запуска (путь к бинарнику + путь к конфигу)
- `Restart=on-failure` — автоматический перезапуск при аварийном завершении
- `User=nobody` / `Group=nogroup` — запуск от непривилегированного пользователя (безопасность)
- `NoNewPrivileges=true` — запрет на повышение привилегий
- `PrivateTmp=true` — изолированная временная директория `/tmp` (безопасность)

**[Install]** — когда запускать:
- `WantedBy=multi-user.target` — запускать при обычной загрузке системы (multi-user = обычный режим)

**Как установить и использовать:**
```bash
# Скопировать бинарник и конфигурацию
sudo cp simple_http /usr/local/bin/
sudo cp server.conf /etc/simple_http.conf

# Установить файл службы
sudo cp simple_http.service /etc/systemd/system/

# Перечитать конфигурацию systemd
sudo systemctl daemon-reload

# Запустить службу
sudo systemctl start simple_http

# Включить автозапуск при загрузке
sudo systemctl enable simple_http

# Проверить статус
sudo systemctl status simple_http

# Посмотреть логи
sudo journalctl -u simple_http -f
```

---

### 3.9. Makefile (система сборки)

**Что это:** Makefile — файл с инструкциями для утилиты `make`, которая автоматизирует сборку проекта.

**Зачем используется:** Чтобы не вводить длинные команды gcc вручную. Одна команда `make` компилирует весь проект.

**Содержимое `Makefile`:**
```makefile
CC=gcc
CFLAGS=-Wall -Wextra -std=c11 -O2 -g
SRC=$(wildcard src/*.c)
OBJ=$(SRC:.c=.o)
BIN=simple_http

all: $(BIN)

$(BIN): $(OBJ)
	$(CC) $(CFLAGS) -o $@ $^

clean:
	rm -f $(OBJ) $(BIN)
```

**Разбор:**

| Строка | Что делает |
|---|---|
| `CC=gcc` | Компилятор — gcc |
| `CFLAGS=-Wall -Wextra -std=c11 -O2 -g` | Флаги компиляции (подробнее ниже) |
| `SRC=$(wildcard src/*.c)` | Все файлы `.c` из папки `src/` |
| `OBJ=$(SRC:.c=.o)` | Для каждого `.c` файла — соответствующий `.o` (объектный файл) |
| `BIN=simple_http` | Имя итогового бинарника |
| `all: $(BIN)` | Цель по умолчанию — собрать бинарник |
| `$(BIN): $(OBJ)` | Бинарник зависит от всех объектных файлов |
| `$(CC) $(CFLAGS) -o $@ $^` | Линковка: собрать все `.o` в один исполняемый файл |
| `clean:` | Удалить все скомпилированные файлы |

**Процесс сборки:**
1. `make` видит, что нужно собрать `simple_http`
2. Для этого нужны `.o` файлы
3. Каждый `.c` файл компилируется в `.o` (объектный файл с машинным кодом)
4. Все `.o` файлы линкуются в один исполняемый файл `simple_http`

---

### 3.10. GCC (компилятор)

**Что это:** GCC (GNU Compiler Collection) — компилятор, который преобразует исходный код на C в машинный код (исполняемый файл).

**Зачем используется:** Задание требует «выполнить отладку кода в gcc». GCC — стандартный компилятор для Linux.

**Используемые флаги:**

| Флаг | Что делает |
|---|---|
| `-Wall` | Включает основные предупреждения (неиспользуемые переменные, неявные преобразования типов и т.д.) |
| `-Wextra` | Включает дополнительные предупреждения (более строгие проверки) |
| `-std=c11` | Использовать стандарт языка C11 |
| `-O2` | Оптимизация второго уровня (ускоряет программу) |
| `-g` | Включает отладочную информацию (для gdb и valgrind) |

**Флаг `-g` особенно важен:** он добавляет в бинарник информацию о номерах строк и именах переменных. Благодаря этому:
- **gdb** может показывать, в какой строке кода произошла ошибка
- **valgrind** может указать, в какой строке произошла утечка памяти

**Пример отладки через gdb:**
```bash
make                              # Собрать с флагом -g
gdb ./simple_http                 # Запустить отладчик
(gdb) break start_server          # Поставить точку останова
(gdb) run server.conf             # Запустить с конфигом
(gdb) next                        # Следующая строка
(gdb) print c->port               # Посмотреть значение переменной
```

---

### 3.11. Valgrind (профилирование памяти)

**Что это:** Valgrind — инструмент для обнаружения ошибок работы с памятью. Он запускает программу в виртуальном окружении и отслеживает каждое обращение к памяти.

**Зачем используется:** Задание требует «выполнить профилирование в valgrind». Valgrind находит утечки памяти, обращения к неинициализированной памяти, выход за границы массивов.

**Как запустить:**
```bash
# Проверка утечек памяти
valgrind --leak-check=full ./simple_http server.conf

# Подробный вывод (показывает каждое обращение к памяти)
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./simple_http server.conf
```

**Что проверяет Valgrind:**

| Ошибка | Описание |
|---|---|
| Memory leak | Выделенная память (`malloc`) не была освобождена (`free`) |
| Invalid read/write | Обращение к памяти за пределами выделенного блока |
| Use of uninitialized value | Использование переменной, которой не было присвоено значение |
| Invalid free | Двойное освобождение или освобождение не-malloc памяти |

**В контексте данного проекта:**
- В `parse_multipart` используется `malloc` для буфера тела запроса. Буфер корректно освобождается через `free(buf)` во всех ветках (как при успехе, так и при ошибке).
- Остальной код использует только локальные переменные на стеке — утечки невозможны.
- Сервер работает в бесконечном цикле, поэтому для тестирования через Valgrind нужно отправить запрос, а затем завершить сервер через Ctrl+C.

---

## 4. Как работает программа

### 4.1. Запуск сервера

При запуске программы выполняется:

1. **`main.c`** — точка входа:
   ```c
   int main(int c, char **v) {
       server_config_t cfg;
       default_config(&cfg);          // Заполняем значениями по умолчанию
       if (c > 1) load_config(v[1], &cfg);  // Если есть аргумент — читаем конфиг
       return start_server(&cfg);     // Запускаем сервер
   }
   ```

2. **`config.c`** — загрузка конфигурации:
   - Сначала заполняются значения по умолчанию (адрес 0.0.0.0, порт 8080 и т.д.)
   - Если передан путь к файлу конфигурации — значения считываются из файла

3. **`server.c`** — инициализация сервера:
   - Создается TCP-сокет
   - Устанавливается опция `SO_REUSEADDR`
   - Сокет привязывается к адресу и порту из конфигурации
   - Начинается прослушивание (`listen`)
   - Создается директория для загрузок (если не существует)
   - Игнорируется сигнал SIGPIPE (чтобы сервер не падал при разрыве соединения)
   - Выводится информация о запуске в stderr

### 4.2. Цикл обработки соединений

Сервер работает в бесконечном цикле (`for(;;)`):

```
Ожидание нового клиента (accept)
  ↓
Установка таймаутов (10 сек)
  ↓
Чтение HTTP-запроса (recv)
  ↓
Разбор заголовков (parse_http_headers)
  ↓
GET запрос?  → Отдаём HTML-форму
POST /upload? → Проверка авторизации → Парсинг файла → Сохранение
Другое?      → Ответ 404
  ↓
Закрытие соединения (close)
  ↓
Возврат к ожиданию нового клиента
```

Сервер **однопоточный**: в один момент времени обрабатывается только один клиент. Пока один запрос обрабатывается, остальные ждут в очереди.

### 4.3. Разбор HTTP-запроса

Функция `parse_http_headers` (`src/http_request.c`) разбирает текст HTTP-запроса:

1. `sscanf(b, "%7s %127s", r->method, r->path)` — извлекает метод (GET/POST) и путь (/upload)
2. `strstr(b, "Content-Length:")` — ищет заголовок с размером тела
3. `strstr(b, "Content-Type:")` — ищет тип содержимого (нужен для boundary)
4. `strstr(b, "Authorization:")` — ищет заголовок авторизации

Результат сохраняется в структуру `http_request_t`.

### 4.4. Обработка GET-запроса

Если метод = GET и путь = `/` или `/index.html`:
- Функция `send_html_form` формирует HTTP-ответ с HTML-страницей
- Указывает `Content-Type: text/html` и правильный `Content-Length`
- Браузер получает и отображает форму с кнопкой загрузки файла

Для любого другого пути — ответ 404 Not Found.

### 4.5. Обработка POST-запроса (загрузка файла)

Это самая сложная часть. Пошагово:

1. **Проверка авторизации** — если включена, вызывается `check_auth`
2. **Извлечение boundary** — из заголовка `Content-Type` достаётся строка-разделитель
3. **Поиск тела в буфере** — находим `\r\n\r\n`, всё после — это начало тела запроса
4. **Создание временного файла** — открываем `upload_dir/upload.bin` для записи
5. **Парсинг multipart** — функция `parse_multipart`:
   - Принимает уже прочитанные данные тела + дочитывает остальное из сокета
   - Находит boundary-маркер
   - Извлекает имя файла из `Content-Disposition`
   - Записывает данные файла в файл
6. **Переименование** — если удалось извлечь настоящее имя файла, переименовываем `upload.bin` → настоящее имя
7. **Ответ клиенту** — отправляем `200 OK` с текстом «File uploaded: имя_файла»

### 4.6. Авторизация

Авторизация проверяется только для POST-запросов:

1. Из заголовка `Authorization: Basic YWRtaW46YWRtaW4=` берётся Base64-часть
2. Декодируется в `admin:admin`
3. Сравнивается со значением `username:password` из конфигурации
4. Если совпадает — запрос обрабатывается
5. Если не совпадает — возвращается код 401

GET-запрос (для получения формы) работает без авторизации.

---

## 5. Описание каждого файла

### `src/main.c` (точка входа)
Минимальная функция `main`: создаёт конфигурацию, загружает её из файла (если указан), запускает сервер. Всего 7 строк кода.

### `src/server.c` + `src/server.h` (основной сервер)
Самый большой файл (~240 строк). Содержит:
- HTML-форму как строковую константу
- Функцию отправки HTML-формы (`send_html_form`)
- Функцию извлечения boundary (`extract_boundary`)
- Главную функцию `start_server` с TCP-сервером и обработкой запросов

### `src/http_request.c` + `src/http_request.h` (разбор запросов)
Структура `http_request_t` хранит разобранный запрос. Функция `parse_http_headers` заполняет эту структуру из текста запроса.

### `src/http_response.c` + `src/http_response.h` (HTTP-ответы)
Функция `http_error` отправляет HTTP-ответ с заданным кодом ошибки.

### `src/config.c` + `src/config.h` (конфигурация)
Структура `server_config_t` хранит все настройки. Две функции: `default_config` (значения по умолчанию) и `load_config` (чтение из файла).

### `src/auth.c` + `src/auth.h` (авторизация)
Декодер Base64 (`b64`) и функция проверки авторизации (`check_auth`).

### `src/multipart.c` + `src/multipart.h` (парсинг файлов)
Функция `parse_multipart` — получает данные из сокета, разбирает multipart-формат, извлекает имя файла, записывает содержимое файла.

### `src/limits.h` (константы)
Три константы:
- `MAX_HEADER_SIZE` = 8192 байт (максимальный размер HTTP-заголовков)
- `MAX_BODY_SIZE` = 50 МБ (максимальный размер загружаемого файла)
- `SOCKET_TIMEOUT` = 10 секунд (таймаут ожидания данных)

### `Makefile` (сборка)
Автоматическая компиляция всех `.c` файлов и линковка в исполняемый файл `simple_http`.

### `server.conf` (конфигурация)
Настройки сервера: адрес, порт, директория загрузок, логин/пароль, вкл/выкл авторизации.

### `simple_http.service` (служба systemd)
Файл для установки программы как фоновой службы Linux.

### `test.sh` (тесты)
Автоматический скрипт: компилирует проект, запускает сервер, проверяет GET-запрос, POST-загрузку с авторизацией, отклонение неправильного пароля, останавливает сервер.

---

## 6. Сборка, запуск и тестирование

### Сборка
```bash
make          # Скомпилировать
make clean    # Удалить скомпилированные файлы
```

### Запуск
```bash
./simple_http server.conf     # С конфигурацией
./simple_http                 # Со значениями по умолчанию
```

### Тестирование через браузер
1. Запустите сервер
2. Откройте `http://localhost:8080` в браузере
3. Выберите файл и нажмите «Upload»
4. Введите логин `admin` и пароль `admin`

### Тестирование через curl
```bash
# Загрузить файл с авторизацией
curl -u admin:admin -F "file=@document.pdf" http://localhost:8080/upload

# Попробовать без авторизации (должен вернуть 401)
curl -F "file=@document.pdf" http://localhost:8080/upload

# Получить HTML-форму
curl http://localhost:8080/
```

### Автоматические тесты
```bash
bash test.sh
```

### Проверка через Valgrind
```bash
valgrind --leak-check=full ./simple_http server.conf
# В другом терминале:
curl -u admin:admin -F "file=@test.txt" http://localhost:8080/upload
# Завершить сервер через Ctrl+C
```

### Отладка через GDB
```bash
gdb ./simple_http
(gdb) run server.conf
# В другом терминале отправить запрос
# Ctrl+C для остановки в gdb
(gdb) backtrace        # Стек вызовов
(gdb) info locals      # Локальные переменные
```

---

## 7. Найденные и исправленные ошибки

### Ошибка 1 (критическая): потеря данных тела запроса

**Проблема:** Первый `recv()` в `server.c` читал до 8 КБ данных — и заголовки, и начало тела запроса. Но `parse_multipart()` начинал читать тело с нуля из сокета. Данные, которые уже были в буфере вместе с заголовками, терялись. Для маленьких файлов (меньше 8 КБ) это означало полную потерю данных файла.

**Исправление:** Функция `parse_multipart` теперь принимает уже прочитанные данные тела через параметры `initial_data` и `initial_len`. В `server.c` находится граница между заголовками и телом (`\r\n\r\n`), и данные после неё передаются в парсер. Парсер сначала копирует эти данные, затем дочитывает оставшееся из сокета.

### Ошибка 2: неверный Content-Length в ответе об успехе

**Проблема:** При формировании ответа «File uploaded: имя_файла» использовалась длина `strlen(display_name) + 14`, но строка «File uploaded: » содержит 15 символов (включая пробел после двоеточия). Content-Length был на 1 байт меньше реального размера тела.

**Исправление:** Заменено `14` на `15`.

### Ошибка 3: неработающий тест в test.sh

**Проблема:** Скрипт `test.sh` проверял наличие строки «Upload File» в ответе на GET-запрос. Но в HTML-форме заголовок — «File Upload» (слова в другом порядке). Тест всегда завершался с ошибкой.

**Исправление:** Заменено `"Upload File"` на `"File Upload"`.

### Ошибка 4: потенциальное переполнение буфера в config.c

**Проблема:** Функция `load_config` использовала `strcpy` для копирования значений из конфигурационного файла в структуру. Если значение в конфиге длиннее размера поля (например, больше 64 символов для `address`), происходило переполнение буфера.

**Исправление:** Заменено на `strncpy` с явным ограничением длины и гарантированной null-терминацией. Добавлен `memset` для полной очистки структуры при инициализации.

---

## 8. Известные ограничения

1. **Однопоточность** — сервер обрабатывает одного клиента за раз. Если один клиент загружает большой файл, остальные ждут. Для учебного проекта это нормально.

2. **Размер заголовков** — заголовки HTTP-запроса должны помещаться в 8 КБ (`MAX_HEADER_SIZE`). В большинстве случаев этого достаточно.

3. **Размер файла** — максимум 50 МБ (`MAX_BODY_SIZE`). Всё тело запроса загружается в оперативную память целиком.

4. **Бинарные файлы с null-байтами** — парсер multipart использует строковые функции (`strstr`), которые прекращают поиск на null-байте. Для текстовых файлов и большинства бинарных форматов (изображения, PDF) проблем не возникает, так как boundary-маркеры находятся в текстовых частях до и после данных файла.

5. **Безопасность** — Basic Auth передает логин и пароль в открытом виде (Base64 — не шифрование). Для реального использования нужен HTTPS. В рамках учебного задания это допустимо.

6. **Нет поддержки нескольких файлов** — за один запрос можно загрузить только один файл.
